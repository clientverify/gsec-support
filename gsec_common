# This file contains common variables and routines for the gsec scripts *- sh -*

# Packages
LLVM="llvm-2.7"
LLVMGCC="llvm-gcc-4.2-2.7"
LLVMGCC_BIN="llvm-gcc4.2-2.7-x86_64-linux"
KLEE="klee"
UCLIBC="klee-uclibc-0.01-x64"
BOOST="boost_1_42_0"
GOOGLE_PERFTOOLS="google-perftools-1.8.3"
UDIS86="udis86-1.7"
LIBUNWIND="libunwind-1.0.1"
NCURSES="ncurses-5.7"
TETRINET="tetrinet"
ZLIB="zlib-1.2.5"
EXPAT="expat-2.0.1"
XPILOT="xpilot"
XPILOT_LLVM_PREFIX="llvm-"
XPILOT_NATIVE_PREFIX="x86-"

# Repository Branches
KLEE_BRANCH="radixtree"
TETRINET_BRANCH="enumerate"
XPILOT_BRANCH="nuklear-support"

# Source repositories
GIT_HOST="rac@kudzoo.cs.unc.edu"
GIT_DIR="/afs/cs.unc.edu/home/rac/repos/research"
LLVM_GIT="$GIT_HOST:$GIT_DIR/$LLVM.git"
KLEE_GIT="$GIT_HOST:$GIT_DIR/$KLEE.git"
TETRINET_GIT="$GIT_HOST:$GIT_DIR/$TETRINET.git"
XPILOT_GIT="$GIT_HOST:$GIT_DIR/$XPILOT.git"

# Tarball locations
PACKAGE_HOST="rac@kudzoo.cs.unc.edu"
PACKAGE_DIR="$PACKAGE_HOST:/afs/cs.unc.edu/home/rac/public/research/files"
UCLIBC_PACKAGE="$UCLIBC.tgz"
BOOST_PACKAGE="$BOOST.tar.gz"
GOOGLE_PERFTOOLS_PACKAGE="$GOOGLE_PERFTOOLS.tar.gz"
UDIS86_PACKAGE="$UDIS86.tar.gz"
LIBUNWIND_PACKAGE="$LIBUNWIND.tar.gz"
LLVMGCC_PACKAGE="$LLVMGCC.source.tgz"
LLVMGCC_BIN_PACKAGE="$LLVMGCC_BIN.tar.bz2"
NCURSES_PACKAGE="$NCURSES.tar.gz"
ZLIB_PACKAGE="$ZLIB.tar.gz"
EXPAT_PACKAGE="$EXPAT.tar.gz"

# Other
RUN_PREFIX=$(date +%F.%T)
LSF_QUEUE="day"
XLIB_DIR="gsec-support/Xlibs"

initialize_root_directories() 
{
  if [[ -z $ROOT_DIR ]] || [[ ! -e $ROOT_DIR ]]; then
    echo "Valid root directory required. Use commandline option '-r dir-name'"
    exit
  fi

  UCLIBC_ROOT="$ROOT_DIR/src/$UCLIBC"
  KLEE_ROOT="$ROOT_DIR/local"
  LLVM_ROOT="$ROOT_DIR/local"
  BOOST_ROOT="$ROOT_DIR/local"
  LLVMGCC_ROOT="$ROOT_DIR/local"
  LIBUNWIND_ROOT="$ROOT_DIR/local"
  NCURSES_ROOT="$ROOT_DIR/local"
  GOOGLE_PERFTOOLS_ROOT="$ROOT_DIR/local"
  TETRINET_ROOT="$ROOT_DIR/local"
  ZLIB_ROOT="$ROOT_DIR/local"
  EXPAT_ROOT="$ROOT_DIR/local"
  XPILOT_ROOT="$ROOT_DIR/local"
  DATA_DIR="$ROOT_DIR/data"
}

### echo message to screen and log to file (even when verbose is disabled)
lecho()
{
  echo "[ $@ ]"
  if test ${LOG_FILE+defined}; then
    if test ! ${DRY_RUN+defined}; then
      eval echo "LOG: $@" >> $LOG_FILE 2>&1
    fi
  fi
}

### echo message to screen if not in verbose mode
necho()
{
  if ! [ $VERBOSE_OUTPUT -eq 1 ]; then
    echo -ne "$@"
  fi
}

###  Initialize gsec logging directories
initialize_logging()
{
  LOG_DIR=$DATA_DIR/logs

  mkdir -p $LOG_DIR

  SCRIPT_BASENAME=`basename $0 .sh`

  LOG_FILE_BASENAME=$SCRIPT_BASENAME"_"$RUN_PREFIX".log"
  LOG_FILE=$LOG_DIR/$LOG_FILE_BASENAME
  RECENT_LOG_FILE=$SCRIPT_BASENAME"_recent.log"

  if [ $VERBOSE_OUTPUT -eq 1 ]; then
    LOGGER=" 2>&1 | tee -a $LOG_FILE"
  else
    LOGGER=">> $LOG_FILE 2>&1 "
  fi

  touch $LOG_FILE
  ln -sf $LOG_FILE_BASENAME $LOG_DIR/$RECENT_LOG_FILE

  echo "LOG: `date` $(basename $0) $@ " >> $LOG_FILE
}



###  Initialize gsec logging directories under LSF(killdevil)
initialize_lsf()
{
  SCRIPT_BASENAME=`basename $0 .sh`
  LSF_LOG_DIR_BASENAME=$SCRIPT_BASENAME"_lsf_"$RUN_PREFIX
  RECENT_LSF_LOG_DIR=$SCRIPT_BASENAME"_lsf_recent"
  LSF_LOG_DIR=$LOG_DIR/$LSF_LOG_DIR_BASENAME

  mkdir -p $LSF_LOG_DIR
  ln -sfT $LSF_LOG_DIR_BASENAME $LOG_DIR/$RECENT_LSF_LOG_DIR
}

###  Get the current git branch name
git_current_branch()
{
  git status | head -n 1 | awk '{ printf $4 }'
}

###  Elapsed time utility
# Usage:
# start_time=$(elapsed_time)
# ...
# end_time=$(elapsed_time $start_time)
elapsed_time()
{
  if [[ $# -eq 0 ]]; then
    echo $(date '+%s')
  else
    local  stime=$1
    etime=$(date '+%s')

    if [[ -z "$stime" ]]; then stime=$etime; fi

    dt=$((etime - stime))
    ds=$((dt % 60))
    dm=$(((dt / 60) % 60))
    dh=$((dt / 3600))
    printf '%d:%02d:%02d' $dh $dm $ds
  fi
}

### GCC Version utilities
_gcc_fullversion() {
  if [[ $# -gt 1 ]]; then
    local VERS_CC=$2
  else
    local VERS_CC=gcc
  fi
  local ver="$1"; shift
  set -- `$VERS_CC -E -P - <<<"__GNUC__ __GNUC_MINOR__ __GNUC_PATCHLEVEL__"`
  eval echo "$ver"
}
gcc-fullversion() {  
  _gcc_fullversion '$1.$2.$3' "$@" 
}
gcc-version() {  
  _gcc_fullversion '$1.$2' "$@" 
}
gcc-major-version() {  
  _gcc_fullversion '$1' "$@"
}
gcc-minor-version() {
  _gcc_fullversion '$2' "$@"
}

set_alternate_gcc()
{
  ALTCC=gcc-4.4
  ALTCXX=g++-4.4
  GXX_INCLUDE_DIR="/usr/include/c++/4.4"
  lecho "Using gcc version $(gcc-fullversion $ALTCC) instead of $(gcc-fullversion)"
}

check_gcc_version()
{
  if [ $(gcc-minor-version) -ge 5 ]; then
    set_alternate_gcc
  fi
}

### user confirmation utility
confirm ()
{
  # call with a prompt string or use a default
  read -r -p "${1:-Are you sure? [Y/n]} " response
  case $response in
    [yY][eE][sS]|[yY]) 
      true
      ;;
    *)
      false
      ;;
  esac
}

### Query /proc/cpuinfo to determine optimum thread count for make
# (currently using NUM_CPU*2)
max_threads()
{
  grep "^processor" /proc/cpuinfo | tail -n 1 | awk -F' ' '{ printf ($3+1)*2 }'
}

### Execute command, automatically logs and checks if this is a dry run
leval()
{
  eval "echo 'EXEC ($(pwd -P))\$ $@' $LOGGER"
  if test ! ${DRY_RUN+defined}; then
    eval $@ $LOGGER
  fi
}

### Execute command directly into gdb, checks if this is a dry run
# but doesn't log any output
geval()
{
  eval "echo 'EXEC ($(pwd -P))\$ gdb -ex run --args $@' $LOGGER"
  if test ! ${DRY_RUN+defined}; then
    eval gdb -ex run --args $@
  fi
}

# Logging bsub function
lbsub()
{
  local bsub_command="bsub -M $(($MAX_MEMORY/1000)) -q $LSF_QUEUE -o $LSF_LOG_DIR/%J"
  eval "echo 'EXEC ($(pwd -P))\$ $bsub_command $@' $LOGGER"
  if test ! ${DRY_RUN+defined}; then
    bsub -M $(($MAX_MEMORY/1000)) -q $LSF_QUEUE -o $LSF_LOG_DIR/out.%J $@
  fi
}

